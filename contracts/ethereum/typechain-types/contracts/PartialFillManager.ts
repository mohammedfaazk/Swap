/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace IPartialFill {
  export type FillOrderStruct = {
    swapId: BytesLike;
    resolver: AddressLike;
    amount: BigNumberish;
    bidPrice: BigNumberish;
    timestamp: BigNumberish;
    merkleRoot: BytesLike;
    executed: boolean;
  };

  export type FillOrderStructOutput = [
    swapId: string,
    resolver: string,
    amount: bigint,
    bidPrice: bigint,
    timestamp: bigint,
    merkleRoot: string,
    executed: boolean
  ] & {
    swapId: string;
    resolver: string;
    amount: bigint;
    bidPrice: bigint;
    timestamp: bigint;
    merkleRoot: string;
    executed: boolean;
  };
}

export interface PartialFillManagerInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "AUCTION_DURATION"
      | "MIN_BID_INCREMENT"
      | "auctions"
      | "executeFillOrders"
      | "fillOrders"
      | "getCurrentPrice"
      | "getFillOrders"
      | "placeBid"
      | "resolverBids"
      | "startAuction"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic: "AuctionStarted" | "BidPlaced" | "FillOrderExecuted"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "AUCTION_DURATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_BID_INCREMENT",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "auctions", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "executeFillOrders",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrders",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentPrice",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getFillOrders",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "placeBid",
    values: [BytesLike, BigNumberish, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "resolverBids",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "startAuction",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "AUCTION_DURATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_BID_INCREMENT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "auctions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeFillOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fillOrders", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFillOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "placeBid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resolverBids",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startAuction",
    data: BytesLike
  ): Result;
}

export namespace AuctionStartedEvent {
  export type InputTuple = [
    swapId: BytesLike,
    startPrice: BigNumberish,
    reservePrice: BigNumberish
  ];
  export type OutputTuple = [
    swapId: string,
    startPrice: bigint,
    reservePrice: bigint
  ];
  export interface OutputObject {
    swapId: string;
    startPrice: bigint;
    reservePrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BidPlacedEvent {
  export type InputTuple = [
    swapId: BytesLike,
    resolver: AddressLike,
    bidPrice: BigNumberish
  ];
  export type OutputTuple = [
    swapId: string,
    resolver: string,
    bidPrice: bigint
  ];
  export interface OutputObject {
    swapId: string;
    resolver: string;
    bidPrice: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FillOrderExecutedEvent {
  export type InputTuple = [
    swapId: BytesLike,
    resolver: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [swapId: string, resolver: string, amount: bigint];
  export interface OutputObject {
    swapId: string;
    resolver: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface PartialFillManager extends BaseContract {
  connect(runner?: ContractRunner | null): PartialFillManager;
  waitForDeployment(): Promise<this>;

  interface: PartialFillManagerInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  AUCTION_DURATION: TypedContractMethod<[], [bigint], "view">;

  MIN_BID_INCREMENT: TypedContractMethod<[], [bigint], "view">;

  auctions: TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, bigint, bigint, bigint, bigint, boolean] & {
        startPrice: bigint;
        reservePrice: bigint;
        startTime: bigint;
        duration: bigint;
        currentPrice: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  executeFillOrders: TypedContractMethod<
    [swapId: BytesLike],
    [void],
    "nonpayable"
  >;

  fillOrders: TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [
      [string, string, bigint, bigint, bigint, string, boolean] & {
        swapId: string;
        resolver: string;
        amount: bigint;
        bidPrice: bigint;
        timestamp: bigint;
        merkleRoot: string;
        executed: boolean;
      }
    ],
    "view"
  >;

  getCurrentPrice: TypedContractMethod<[swapId: BytesLike], [bigint], "view">;

  getFillOrders: TypedContractMethod<
    [swapId: BytesLike],
    [IPartialFill.FillOrderStructOutput[]],
    "view"
  >;

  placeBid: TypedContractMethod<
    [
      swapId: BytesLike,
      bidPrice: BigNumberish,
      fillAmount: BigNumberish,
      merkleProof: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;

  resolverBids: TypedContractMethod<
    [arg0: BytesLike, arg1: AddressLike],
    [boolean],
    "view"
  >;

  startAuction: TypedContractMethod<
    [swapId: BytesLike, startPrice: BigNumberish, reservePrice: BigNumberish],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "AUCTION_DURATION"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MIN_BID_INCREMENT"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "auctions"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, bigint, bigint, bigint, bigint, boolean] & {
        startPrice: bigint;
        reservePrice: bigint;
        startTime: bigint;
        duration: bigint;
        currentPrice: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "executeFillOrders"
  ): TypedContractMethod<[swapId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "fillOrders"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: BigNumberish],
    [
      [string, string, bigint, bigint, bigint, string, boolean] & {
        swapId: string;
        resolver: string;
        amount: bigint;
        bidPrice: bigint;
        timestamp: bigint;
        merkleRoot: string;
        executed: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCurrentPrice"
  ): TypedContractMethod<[swapId: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getFillOrders"
  ): TypedContractMethod<
    [swapId: BytesLike],
    [IPartialFill.FillOrderStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "placeBid"
  ): TypedContractMethod<
    [
      swapId: BytesLike,
      bidPrice: BigNumberish,
      fillAmount: BigNumberish,
      merkleProof: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "resolverBids"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "startAuction"
  ): TypedContractMethod<
    [swapId: BytesLike, startPrice: BigNumberish, reservePrice: BigNumberish],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "AuctionStarted"
  ): TypedContractEvent<
    AuctionStartedEvent.InputTuple,
    AuctionStartedEvent.OutputTuple,
    AuctionStartedEvent.OutputObject
  >;
  getEvent(
    key: "BidPlaced"
  ): TypedContractEvent<
    BidPlacedEvent.InputTuple,
    BidPlacedEvent.OutputTuple,
    BidPlacedEvent.OutputObject
  >;
  getEvent(
    key: "FillOrderExecuted"
  ): TypedContractEvent<
    FillOrderExecutedEvent.InputTuple,
    FillOrderExecutedEvent.OutputTuple,
    FillOrderExecutedEvent.OutputObject
  >;

  filters: {
    "AuctionStarted(bytes32,uint256,uint256)": TypedContractEvent<
      AuctionStartedEvent.InputTuple,
      AuctionStartedEvent.OutputTuple,
      AuctionStartedEvent.OutputObject
    >;
    AuctionStarted: TypedContractEvent<
      AuctionStartedEvent.InputTuple,
      AuctionStartedEvent.OutputTuple,
      AuctionStartedEvent.OutputObject
    >;

    "BidPlaced(bytes32,address,uint256)": TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;
    BidPlaced: TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;

    "FillOrderExecuted(bytes32,address,uint256)": TypedContractEvent<
      FillOrderExecutedEvent.InputTuple,
      FillOrderExecutedEvent.OutputTuple,
      FillOrderExecutedEvent.OutputObject
    >;
    FillOrderExecuted: TypedContractEvent<
      FillOrderExecutedEvent.InputTuple,
      FillOrderExecutedEvent.OutputTuple,
      FillOrderExecutedEvent.OutputObject
    >;
  };
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface StellarBridgeFusionPlusInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "MAX_TIMELOCK"
      | "MIN_TIMELOCK"
      | "PARTIAL_FILL_FEE"
      | "RESOLVER_MIN_STAKE"
      | "completeSwap"
      | "executePartialFill"
      | "feeRecipient"
      | "getAnalytics"
      | "getSwapDetails"
      | "initiateSwap"
      | "owner"
      | "pause"
      | "paused"
      | "refundSwap"
      | "registerResolver"
      | "renounceOwnership"
      | "resolvers"
      | "setFeeRecipient"
      | "swaps"
      | "totalResolverRewards"
      | "totalSwapVolume"
      | "transferOwnership"
      | "unpause"
      | "usedSecrets"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "OwnershipTransferred"
      | "PartialFillExecuted"
      | "Paused"
      | "ResolverRegistered"
      | "SwapCompleted"
      | "SwapInitiated(bytes32,address,address,uint256,bytes32,uint256,string,bool)"
      | "SwapInitiated(bytes32)"
      | "Unpaused"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "MAX_TIMELOCK",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MIN_TIMELOCK",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PARTIAL_FILL_FEE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "RESOLVER_MIN_STAKE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "completeSwap",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "executePartialFill",
    values: [BytesLike, BigNumberish, BytesLike[], BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "feeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAnalytics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapDetails",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initiateSwap",
    values: [
      AddressLike,
      BigNumberish,
      BytesLike,
      BigNumberish,
      string,
      boolean,
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "refundSwap",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerResolver",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "resolvers",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeRecipient",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "swaps", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "totalResolverRewards",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalSwapVolume",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "usedSecrets",
    values: [BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "MAX_TIMELOCK",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MIN_TIMELOCK",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PARTIAL_FILL_FEE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "RESOLVER_MIN_STAKE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "completeSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePartialFill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAnalytics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSwapDetails",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "refundSwap", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerResolver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resolvers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swaps", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalResolverRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSwapVolume",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "usedSecrets",
    data: BytesLike
  ): Result;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PartialFillExecutedEvent {
  export type InputTuple = [
    swapId: BytesLike,
    resolver: AddressLike,
    fillAmount: BigNumberish,
    totalFilled: BigNumberish,
    merkleRoot: BytesLike,
    gasRebate: BigNumberish
  ];
  export type OutputTuple = [
    swapId: string,
    resolver: string,
    fillAmount: bigint,
    totalFilled: bigint,
    merkleRoot: string,
    gasRebate: bigint
  ];
  export interface OutputObject {
    swapId: string;
    resolver: string;
    fillAmount: bigint;
    totalFilled: bigint;
    merkleRoot: string;
    gasRebate: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ResolverRegisteredEvent {
  export type InputTuple = [
    resolver: AddressLike,
    stake: BigNumberish,
    reputation: BigNumberish
  ];
  export type OutputTuple = [
    resolver: string,
    stake: bigint,
    reputation: bigint
  ];
  export interface OutputObject {
    resolver: string;
    stake: bigint;
    reputation: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapCompletedEvent {
  export type InputTuple = [
    swapId: BytesLike,
    resolver: AddressLike,
    secret: BytesLike,
    totalAmount: BigNumberish,
    resolverReward: BigNumberish
  ];
  export type OutputTuple = [
    swapId: string,
    resolver: string,
    secret: string,
    totalAmount: bigint,
    resolverReward: bigint
  ];
  export interface OutputObject {
    swapId: string;
    resolver: string;
    secret: string;
    totalAmount: bigint;
    resolverReward: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event {
  export type InputTuple = [
    swapId: BytesLike,
    initiator: AddressLike,
    token: AddressLike,
    amount: BigNumberish,
    secretHash: BytesLike,
    timelock: BigNumberish,
    stellarAccount: string,
    partialFillEnabled: boolean
  ];
  export type OutputTuple = [
    swapId: string,
    initiator: string,
    token: string,
    amount: bigint,
    secretHash: string,
    timelock: bigint,
    stellarAccount: string,
    partialFillEnabled: boolean
  ];
  export interface OutputObject {
    swapId: string;
    initiator: string;
    token: string;
    amount: bigint;
    secretHash: string;
    timelock: bigint;
    stellarAccount: string;
    partialFillEnabled: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapInitiated_bytes32_Event {
  export type InputTuple = [id: BytesLike];
  export type OutputTuple = [id: string];
  export interface OutputObject {
    id: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface StellarBridgeFusionPlus extends BaseContract {
  connect(runner?: ContractRunner | null): StellarBridgeFusionPlus;
  waitForDeployment(): Promise<this>;

  interface: StellarBridgeFusionPlusInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  MAX_TIMELOCK: TypedContractMethod<[], [bigint], "view">;

  MIN_TIMELOCK: TypedContractMethod<[], [bigint], "view">;

  PARTIAL_FILL_FEE: TypedContractMethod<[], [bigint], "view">;

  RESOLVER_MIN_STAKE: TypedContractMethod<[], [bigint], "view">;

  completeSwap: TypedContractMethod<
    [swapId: BytesLike, secret: BytesLike],
    [void],
    "nonpayable"
  >;

  executePartialFill: TypedContractMethod<
    [
      swapId: BytesLike,
      fillAmount: BigNumberish,
      merkleProof: BytesLike[],
      nonce: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  feeRecipient: TypedContractMethod<[], [string], "view">;

  getAnalytics: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        _totalSwapVolume: bigint;
        _totalResolverRewards: bigint;
        _activeSwaps: bigint;
        _totalResolvers: bigint;
      }
    ],
    "view"
  >;

  getSwapDetails: TypedContractMethod<
    [swapId: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        initiator: string;
        token: string;
        amount: bigint;
        filled: bigint;
        secretHash: string;
        timelock: bigint;
        stellarAccount: string;
        state: bigint;
        partialFillEnabled: boolean;
      }
    ],
    "view"
  >;

  initiateSwap: TypedContractMethod<
    [
      token: AddressLike,
      amount: BigNumberish,
      secretHash: BytesLike,
      timelock: BigNumberish,
      stellarAccount: string,
      partialFillEnabled: boolean,
      merkleRoot: BytesLike
    ],
    [string],
    "nonpayable"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  pause: TypedContractMethod<[], [void], "nonpayable">;

  paused: TypedContractMethod<[], [boolean], "view">;

  refundSwap: TypedContractMethod<[swapId: BytesLike], [void], "nonpayable">;

  registerResolver: TypedContractMethod<[], [void], "payable">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  resolvers: TypedContractMethod<
    [arg0: AddressLike],
    [
      [bigint, bigint, bigint, bigint, boolean] & {
        stake: bigint;
        reputation: bigint;
        totalVolume: bigint;
        successRate: bigint;
        active: boolean;
      }
    ],
    "view"
  >;

  setFeeRecipient: TypedContractMethod<
    [_feeRecipient: AddressLike],
    [void],
    "nonpayable"
  >;

  swaps: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        boolean,
        string
      ] & {
        initiator: string;
        token: string;
        amount: bigint;
        filled: bigint;
        secretHash: string;
        timelock: bigint;
        stellarAccount: string;
        state: bigint;
        partialFillEnabled: boolean;
        merkleRoot: string;
      }
    ],
    "view"
  >;

  totalResolverRewards: TypedContractMethod<[], [bigint], "view">;

  totalSwapVolume: TypedContractMethod<[], [bigint], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  unpause: TypedContractMethod<[], [void], "nonpayable">;

  usedSecrets: TypedContractMethod<[arg0: BytesLike], [boolean], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "MAX_TIMELOCK"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MIN_TIMELOCK"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "PARTIAL_FILL_FEE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "RESOLVER_MIN_STAKE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "completeSwap"
  ): TypedContractMethod<
    [swapId: BytesLike, secret: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executePartialFill"
  ): TypedContractMethod<
    [
      swapId: BytesLike,
      fillAmount: BigNumberish,
      merkleProof: BytesLike[],
      nonce: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "feeRecipient"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getAnalytics"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint] & {
        _totalSwapVolume: bigint;
        _totalResolverRewards: bigint;
        _activeSwaps: bigint;
        _totalResolvers: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSwapDetails"
  ): TypedContractMethod<
    [swapId: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        boolean
      ] & {
        initiator: string;
        token: string;
        amount: bigint;
        filled: bigint;
        secretHash: string;
        timelock: bigint;
        stellarAccount: string;
        state: bigint;
        partialFillEnabled: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "initiateSwap"
  ): TypedContractMethod<
    [
      token: AddressLike,
      amount: BigNumberish,
      secretHash: BytesLike,
      timelock: BigNumberish,
      stellarAccount: string,
      partialFillEnabled: boolean,
      merkleRoot: BytesLike
    ],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "paused"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "refundSwap"
  ): TypedContractMethod<[swapId: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "registerResolver"
  ): TypedContractMethod<[], [void], "payable">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "resolvers"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [bigint, bigint, bigint, bigint, boolean] & {
        stake: bigint;
        reputation: bigint;
        totalVolume: bigint;
        successRate: bigint;
        active: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "setFeeRecipient"
  ): TypedContractMethod<[_feeRecipient: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "swaps"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        string,
        bigint,
        string,
        bigint,
        boolean,
        string
      ] & {
        initiator: string;
        token: string;
        amount: bigint;
        filled: bigint;
        secretHash: string;
        timelock: bigint;
        stellarAccount: string;
        state: bigint;
        partialFillEnabled: boolean;
        merkleRoot: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "totalResolverRewards"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalSwapVolume"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "unpause"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "usedSecrets"
  ): TypedContractMethod<[arg0: BytesLike], [boolean], "view">;

  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "PartialFillExecuted"
  ): TypedContractEvent<
    PartialFillExecutedEvent.InputTuple,
    PartialFillExecutedEvent.OutputTuple,
    PartialFillExecutedEvent.OutputObject
  >;
  getEvent(
    key: "Paused"
  ): TypedContractEvent<
    PausedEvent.InputTuple,
    PausedEvent.OutputTuple,
    PausedEvent.OutputObject
  >;
  getEvent(
    key: "ResolverRegistered"
  ): TypedContractEvent<
    ResolverRegisteredEvent.InputTuple,
    ResolverRegisteredEvent.OutputTuple,
    ResolverRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "SwapCompleted"
  ): TypedContractEvent<
    SwapCompletedEvent.InputTuple,
    SwapCompletedEvent.OutputTuple,
    SwapCompletedEvent.OutputObject
  >;
  getEvent(
    key: "SwapInitiated(bytes32,address,address,uint256,bytes32,uint256,string,bool)"
  ): TypedContractEvent<
    SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.InputTuple,
    SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.OutputTuple,
    SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.OutputObject
  >;
  getEvent(
    key: "SwapInitiated(bytes32)"
  ): TypedContractEvent<
    SwapInitiated_bytes32_Event.InputTuple,
    SwapInitiated_bytes32_Event.OutputTuple,
    SwapInitiated_bytes32_Event.OutputObject
  >;
  getEvent(
    key: "Unpaused"
  ): TypedContractEvent<
    UnpausedEvent.InputTuple,
    UnpausedEvent.OutputTuple,
    UnpausedEvent.OutputObject
  >;

  filters: {
    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "PartialFillExecuted(bytes32,address,uint256,uint256,bytes32,uint256)": TypedContractEvent<
      PartialFillExecutedEvent.InputTuple,
      PartialFillExecutedEvent.OutputTuple,
      PartialFillExecutedEvent.OutputObject
    >;
    PartialFillExecuted: TypedContractEvent<
      PartialFillExecutedEvent.InputTuple,
      PartialFillExecutedEvent.OutputTuple,
      PartialFillExecutedEvent.OutputObject
    >;

    "Paused(address)": TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;
    Paused: TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;

    "ResolverRegistered(address,uint256,uint256)": TypedContractEvent<
      ResolverRegisteredEvent.InputTuple,
      ResolverRegisteredEvent.OutputTuple,
      ResolverRegisteredEvent.OutputObject
    >;
    ResolverRegistered: TypedContractEvent<
      ResolverRegisteredEvent.InputTuple,
      ResolverRegisteredEvent.OutputTuple,
      ResolverRegisteredEvent.OutputObject
    >;

    "SwapCompleted(bytes32,address,bytes32,uint256,uint256)": TypedContractEvent<
      SwapCompletedEvent.InputTuple,
      SwapCompletedEvent.OutputTuple,
      SwapCompletedEvent.OutputObject
    >;
    SwapCompleted: TypedContractEvent<
      SwapCompletedEvent.InputTuple,
      SwapCompletedEvent.OutputTuple,
      SwapCompletedEvent.OutputObject
    >;

    "SwapInitiated(bytes32,address,address,uint256,bytes32,uint256,string,bool)": TypedContractEvent<
      SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.InputTuple,
      SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.OutputTuple,
      SwapInitiated_bytes32_address_address_uint256_bytes32_uint256_string_bool_Event.OutputObject
    >;
    "SwapInitiated(bytes32)": TypedContractEvent<
      SwapInitiated_bytes32_Event.InputTuple,
      SwapInitiated_bytes32_Event.OutputTuple,
      SwapInitiated_bytes32_Event.OutputObject
    >;

    "Unpaused(address)": TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
    Unpaused: TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
  };
}
